Разработка Торгового Бота на Python
Задание:
Напиши код торгового бота на Python, строго соответствующий всем нижеуказанным требованиям.

Требования:

1. ВНЕШНИЕ СИГНАЛЫ
1.1. Бот получает внешние сигналы "buy" и "sell" из файла состояния bot_state.json.
1.2. На каждой итерации бот сохраняет полученные внешние сигналы в своей конфигурации config_futures.json.
1.3. Допустимые внешние сигналы: только "buy" и "sell".
1.4. "buy" и "sell" применяется в коде только для обозначения внешних сигналов.


2. ОТКРЫТИЕ ПОЗИЦИЙ
2.1. Позиция открывается только при отсутствии открытой позиции по тому же символу и направлению.
2.2. Одновременное открытие длинной и короткой позиций для одного символа разрешено. Фьючерсный аккаунт включен в режим хэджирования и двусторонних позиций.
2.3. Для всех позиций , в том числе одновременно открытых LONG и SHORT позиций, PNL для каждой позиции отдельно рассчитывается по получаемым данным об открытых позициях get_positions по формуле: (pnl / current_value) * 100 * (self.leverage or 1)
2.4. Расчет количества контрактов в открываемой позиции производится по формуле: int(self.config['initial_balance'] / self.config['margin_usage_ratio'] / len(self.config['pairs']) / contract_size).
2.5. contract_size означает стоимость одного контракта по символу. contract_size вычисляется по формуле contract_sizes[symbol] = abs(positions[symbol]['value'] / positions[symbol]['size']) , сохраняется и обновляется в конфигурации. 
2.6. Ордеры для открытия позиций: open_short для коротких позиций, open_long для длинных позиций.
2.7. Высший приоритет: изменение внешнего сигнала а не достижение порога PNL . Изменение внешнего сигнала всегда должно быть приоритетным действием, вне зависимости от трейлинг-стопа и PNL. При одновременном изменении внешнего сигнала и активации трейлинг-стопа : позиция закрывается и открывается новая в соответствии с сигналом.
2.8. Условия для открытия позиции : 
- Отсутствует открытая LONG позиция + текущий внешний сигнал BUY = открывается LONG позиция в количестве контрактов рассчитанном по формуле,
или
- Отсутствует открытая SHORT позиция + текущий внешний сигнал SELL = открывается SHORT позиция в количестве контрактов рассчитанном по формуле,
или
- Отсутствует открытая LONG позиция + открытая SHORT позиция достигла -4% PNL = открывается LONG позиция в количестве контрактов равном количеству в SHORT позиции,
или
- Отсутствует открытая SHORT позиция + открытая LONG позиция достигла -4% PNL = открывается SHORT позиция в количестве контрактов равном количеству в LONG позиции.
2.9. Пример: если одновременно выполняются условия для открытия LONG и SHORT позиций (например, отсутствие открытой LONG позиции и открытая SHORT позиция с -4% PNL) : бот откроет LONG позицию в количестве контрактов равном количеству контрактов в SHORT позиции.
2.10. Если есть условия для открытия нескольких позиций , то бот открывает сразу несколько позиций.
2.11. Для открытия короткой позиции по фьючерсам, размер позиции (size) должен быть отрицательным.
2.12. Для открытия длинной позиции, размер позиции (size) должен быть положительным.
2.13. # Пример кода для открытия короткой позиции (short):
futures_order = FuturesOrder(
    contract="BTC_USDT",  # Торговая пара
    size="-10",  # Отрицательное значение для открытия шортовой позиции
    price="0",  # Рыночная цена (для market order)
    tif="ioc",  # Немедленное выполнение (Immediate or Cancel)
    close=False  # Указывает, что это открытие новой позиции, а не закрытие
)
futures_api.create_futures_order(settle='usdt', futures_order=futures_order)
2.14. # Пример кода для открытия длинной позиции (long):
futures_order = FuturesOrder(
    contract="BTC_USDT",  # Торговая пара
    size="10",  # Положительное значение для открытия лонговой позиции
    price="0",  # Рыночная цена (для market order)
    tif="ioc",  # Немедленное выполнение (Immediate or Cancel)
    close=False  # Указывает, что это открытие новой позиции, а не закрытие
)
futures_api.create_futures_order(settle='usdt', futures_order=futures_order)


3. ЗАКРЫТИЕ ПОЗИЦИЙ
3.1. Позиции всегда закрываются полностью, частичное закрытие не применяется.
3.2. Ордеры для закрытия позиций: close_short для коротких, close_long для длинных позиций.
3.3. Условия для закрытия текущей позиции : 
- открыта LONG позиция по символу + достигнут порог снижения pnl_close_threshold трейлинг-стоп = закрывается LONG позиция,
или
- открыта SHORT позиция по символу + достигнут порог снижения pnl_close_threshold трейлинг-стоп = закрывается SHORT позиция,
или
- одновременно открыты позиции LONG и SHORT по символу + LONG позиция достигла +4% PNL + SHORT позиция PNL < 0 = закрывается SHORT позиция,
или
- одновременно открыты позиции LONG и SHORT по символу + SHORT позиция достигла +4% PNL + LONG позиция PNL < 0 = закрывается LONG позиция,
или
- открыта только LONG позиция + текущий внешний сигнал SELL = закрывается LONG позиция,
или
- открыта только SHORT позиция + текущий внешний сигнал BUY = закрывается SHORT позиция.
3.4. Если текущий внешний сигнал изменился, закрывается позиция без достижения трейлинг-стопа или определённого PNL. Приоритетнее изменение внешнего сигнала. Это соответствует стратегии управления рисками, бот торгует по тренду задаваемому внешним сигналом.После закрытия позиции открывается позиция в соответствии с сигналом.
3.5. Если есть условия для закрытия нескольких позиций , то бот закрывает сразу несколько позиций.
3.6. Для закрытия короткой позиции используется параметр auto_size="close_short" и параметр size=0, который явно указывает на закрытие текущей короткой позиции.
3.7. Для закрытия длинной позиции используется параметр auto_size="close_long" и параметр size=0, который явно указывает на закрытие текущей длинной позиции.
3.8. # Пример кода для закрытия короткой позиции (short):
futures_order = FuturesOrder(
    contract="BTC_USDT",  # Торговая пара
    size="0",  # Указывает, что позиция закрывается
    price="0",  # Рыночная цена (для market order)
    tif="ioc",  # Немедленное выполнение (Immediate or Cancel)
    close=True,  # Указывает, что ордер закрывает позицию
    auto_size="close_short"  # Указывает на закрытие короткой позиции
    reduce_only = True  # Устанавливаем reduce_only в True
)
futures_api.create_futures_order(settle='usdt', futures_order=futures_order)
3.9. # Пример кода для закрытия длинной позиции (long):
futures_order = FuturesOrder(
    contract="BTC_USDT",  # Торговая пара
    size="0",  # Указывает, что позиция закрывается
    price="0",  # Рыночная цена (для market order)
    tif="ioc",  # Немедленное выполнение (Immediate or Cancel)
    close=True,  # Указывает, что ордер закрывает позицию
    auto_size="close_long"  # Указывает на закрытие длинной позиции
    reduce_only = True  # Устанавливаем reduce_only в True
)
futures_api.create_futures_order(settle='usdt', futures_order=futures_order)


4. ТРЕЙЛИНГ-СТОП
4.1. Трейлинг-Стоп активируется при достижении позицией +4% PNL.
4.2. Трейлинг-Стоп не активируется для позиций с PNL < 0.
4.3. При достижении порога снижения pnl_close_threshold позиция полностью закрывается.
4.4. Трейлинг-стоп начинает работать при достижении позицией PNL > +4%. При одновременно открытых LONG и SHORT позициях когда одна из них достигает PNL > +4% , другая позиция с PNL < 0 закрывается - таким образом трейлинг-стоп работает только для одной позиции по символу с PNL > +4% . 
4.5. В случае PNL > 0 у обеих одновременно открытых LONG и SHORT позиций: бот не выполняет никаких операций по символу.
4.6. Трейлинг-стоп реализуется отдельным методом в коде, чтобы он активировался при достижении +4% PNL и закрывал позицию при достижении порога снижения pnl_close_threshold задаваеным из конфигурации . 


5. ТИПЫ ОРДЕРОВ
5.1. Применяются только рыночные ордера (market orders).
5.2. Применяются только команды : open_long, open_short, close_long, close_short.
5.3. Атрибут 'type' для ордеров не применяется.
5.4. Все ордера размещаются только в количестве контрактов.
5.5. Запрещено размещение ордеров в объёме USDT.
5.6. Запрещено размещение ордера на открытие позиции, если позиция по символу в том же направлении уже открыта.
5.7. Расчет количества контрактов по формуле производится для открытия позиций, если не открыта противоположная позиция по символу. 
5.8. Если бот открывает новую позицию одновременно с уже существующей (открывается позиция противоположная текущей), количество контрактов в открываемой позиции равно количеству в текущей позиции (то есть полное хеджирование позиции), обе позиции останутся открытыми.


6. ОПРЕДЕЛЕНИЕ НАПРАВЛЕНИЯ ТЕКУЩЕЙ ПОЗИЦИИ (long или short):
6.1. Информацию о направлении текущей позиции бот получает через поле size используя API для запроса текущих позиций: если size > 0 это лонговая позиция, если size < 0 это шортовая позиция.
6.2. # Пример запроса информации о текущей позиции:
positions = futures_api.list_positions(settle='usdt')
for position in positions:
    if position.contract == "BTC_USDT":
        size = float(position.size)
        if size > 0:
            print("Открыта длинная позиция (long) на", size, "контрактов")
        elif size < 0:
            print("Открыта короткая позиция (short) на", abs(size), "контрактов")
        else:
            print("Нет открытых позиций по BTC_USDT")


7. ОБРАБОТКА ОШИБОК
7.1. Не применяются повторные попытки выполнения операций при неудаче их выполнения и сбоях.
7.2. Реализуется обработка ошибок без повторных попыток, только путём повторения логики на последующих итерациях.
7.3. Логироваться ошибки будут во внешнем файле и в консоли.


8. УПРАВЛЕНИЕ РИСКАМИ
8.1. Нет ограничений на общий суммарный размер позиций.
8.2. Нет стоп-лоссов или тейк-профитов для позиций.
8.3. Бот хранит и обновляет данные о открытых позициях, PNL в своих словарях, внешние сигналы сохраняет и обновляет в своей конфигурации config_futures.json .
8.4. Базы данных не используются, а только словари , файл конфигурации и внешний файл состояния сигналов .
8.5. Ситуация когда PNL позиции быстро колеблется вокруг порогов не рассматривается как возможная.


9. СТРУКТУРА КОДА
9.1. Структура кода: классы, методы.
9.2. Используются любые сторонние библиотеки или фреймворки.


10. ТЕСТИРОВАНИЕ
10.1. Тестирование бота для проверки его корректной работы по всем требованиям: с помощью дополнительно созданного кода содержащего тесты каждого метода и unittest.
10.2. При необходимости используются автоматизированные тесты или симуляции.