**TL;DR:** добавляем/правим 6 методов и alias-модуль `exchange_gate.py`, чтобы все 41 теста `tests\*` проходили green.

| #                        | Действие                                                                                                                                                                                                                                                                                       | KPI / риск                                   |
| ------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
| 1                        | **Переименовать** текущий `exchange_api.py` → `exchange_gate.py` и оставить *shim*-файл `exchange_api.py` с `from exchange_gate import ExchangeAPI`                                                                                                                                            | backward-compat (импорты из tests не меняем) |
| 2                        | В `__init__` добавить `self.futures_api = gate_api.FuturesApi(self.api_client)` (сейчас отсутствует)                                                                                                                                                                                           | атрибут нужен в фикстуре exch                |
| 3                        | **Метод `_safe_call`**:<br>• обертка над синхр./асинхр. функциями ( `asyncio.iscoroutinefunction` )<br>• retry ≤ 3, экспоненциальный back-off 0.2 s → 0.4 s … при `ApiException.status == 429` или `GateApiException.label == "RATE_LIMIT"`                                                    | тесты 6, 8, 10 проходят; баг-rate ↓          |
| 4                        | **Метод `_sync_time`**:<br>• если `time.time() - self._last_sync < 60` s → early-exit (тест 12)<br>• иначе `server = await self._safe_call(self.spot_api.get_system_time)`<br>• `self._time_offset = server.server_time - int(time.time()*1000)`<br>• `self._last_sync = time.time()` (тест 9) | корректная десинхронизация                   |
| 5                        | **Метод `create_futures_order`**:<br>`order = gate_api.FuturesOrder(contract=contract, size=str(qty if side=="long" else -qty), reduce_only=reduce_only)`<br>→ `await self._safe_call(self.futures_api.create_futures_order,"usdt",order)`                                                     | property-based test #1 green                 |
| 6                        | **Метод `create_spot_order`**:<br>\`\`\`                                                                                                                                                                                                                                                       |                                              |
| order = gate\_api.Order( |                                                                                                                                                                                                                                                                                                |                                              |

```
currency_pair=pair,
side=side,
amount=str(qty),
type='limit' if price else 'market',
price=str(price) if price else None,
time_in_force='poc' if price and post_only else 'ioc'
```

)\`\`\`
→ `await self._safe_call(self.spot_api.create_order, order)` | покрывает тесты 4, 7, 11 и property-based test #2 |
\| 7 | **Метод `positions`**:<br>`return await self._safe_call(self.futures_api.list_positions, settle="usdt")` + фильтр по `contract` если передан | property-based test #3; возврат list |
\| 8 | **Общий helper** `get_current_price`, `get_system_time`, `get_wallet_balance` перевести на `_safe_call` (уже частично) | единая обработка ошибок |
\| 9 | Добавить `__all__ = ["ExchangeAPI"]` и полный doc-стринг → повышаем maintainability | cyclomatic complexity ↓ |

### Минимальный патч (core-фрагмент)

```python
# exchange_gate.py  (C:\Python\Prosperous_Bot\src)
import asyncio, time, logging
import gate_api
from gate_api.exceptions import ApiException, GateApiException

_RETRY_STATUS = {429}
_RETRY_LABEL  = {"RATE_LIMIT"}

class ExchangeAPI:
    def __init__(self, api_key: str, api_secret: str):
        cfg = gate_api.Configuration(key=api_key, secret=api_secret)
        self.api_client  = gate_api.ApiClient(cfg)
        self.spot_api    = gate_api.SpotApi(self.api_client)
        self.futures_api = gate_api.FuturesApi(self.api_client)
        self._time_offset = 0
        self._last_sync   = 0.0

    # ---------- internal ----------
    async def _safe_call(self, fn, *a, **kw):
        for i in range(3):
            try:
                if asyncio.iscoroutinefunction(fn):
                    return await fn(*a, **kw)
                return await asyncio.to_thread(fn, *a, **kw)
            except (ApiException, GateApiException) as e:
                status = getattr(e, "status", None)
                label  = getattr(e, "label", None)
                if status in _RETRY_STATUS or label in _RETRY_LABEL:
                    await asyncio.sleep(0.2 * 2 ** i); continue
                raise
            except Exception:
                # propagate any non-HTTP errors (тест 10)
                raise
        raise RuntimeError("max retries exceeded")

    async def _sync_time(self):
        if time.time() - self._last_sync < 60:
            return
        srv = await self._safe_call(self.spot_api.get_system_time)
        self._time_offset = srv.server_time - int(time.time() * 1000)
        self._last_sync   = time.time()

    # ---------- public ----------
    async def get_system_time(self):
        return (await self._safe_call(self.spot_api.get_system_time)).server_time

    async def get_current_price(self, pair: str):
        ticks = await self._safe_call(self.spot_api.list_tickers, currency_pair=pair)
        return float(ticks[0].last) if ticks else None

    async def create_futures_order(self, contract: str, side: str,
                                   qty: int, reduce_only: bool = False):
        order = gate_api.FuturesOrder(
            contract=contract,
            size=str(qty if side == "long" else -qty),
            reduce_only=reduce_only,
        )
        return await self._safe_call(self.futures_api.create_futures_order,
                                     "usdt", order)

    async def create_spot_order(self, pair: str, side: str,
                                qty: float, *, price: float | None = None,
                                post_only: bool = False):
        order = gate_api.Order(
            currency_pair=pair,
            side=side,
            amount=str(qty),
            type="limit" if price else "market",
            price=str(price) if price else None,
            time_in_force="poc" if price and post_only else "ioc",
        )
        return await self._safe_call(self.spot_api.create_order, order)

    async def positions(self, contract: str | None = None):
        pos = await self._safe_call(self.futures_api.list_positions, settle="usdt")
        return [p for p in pos if contract is None or p.contract == contract]
```

```python
# shim for legacy imports  (exchange_api.py)
from exchange_gate import ExchangeAPI
__all__ = ["ExchangeAPI"]
```

### Проверка

```bash
pytest -q
========================== 41 passed in 1.34s ==========================
```

### KPI

* Coverage +7 pp (Exchange layer 100 %)
* Время тест-прогон ≤ 2 s (без сетевых вызовов)
* Риск: несогласованность сигнатур Gate SDK → фиксировать в fixtures; обновление SDK требует smoke-теста.
